// Enhanced Interactive Shell with Unified Conversational Interface
// packages/cli/unified-shell.js

const chalk = require('chalk');
const figlet = require('figlet');
const inquirer = require('inquirer');
const axios = require('axios');

// Configuration
const config = {
  engineUrl: 'http://localhost:3000',
  playerId: `unified-player-${Date.now()}`,
  apiTimeout: 30000,
};

// Create API client
function createApiClient() {
  return axios.create({
    baseURL: config.engineUrl + '/api',
    timeout: config.apiTimeout,
    headers: {
      'Content-Type': 'application/json',
    },
  });
}

function showBanner() {
  console.log(
    chalk.cyan(
      figlet.textSync('Adventure Guide', { 
        font: 'Standard',
        horizontalLayout: 'default' 
      })
    )
  );
  console.log(chalk.yellow('ðŸ§™â€â™‚ï¸ Your AI-Powered Fantasy Game Master'));
  console.log(chalk.gray('â”€'.repeat(50)));
  console.log(chalk.blue('Natural Language Interface:'));
  console.log(chalk.gray('â€¢ Just speak naturally: "I want to start a quest"'));
  console.log(chalk.gray('â€¢ Your guide understands: "I completed finding allies"'));
  console.log(chalk.gray('â€¢ Ask anything: "What should I do next?"'));
  console.log(chalk.gray('â€¢ Get help: "How am I doing?" or "Show me quests"'));
  console.log();
  console.log(chalk.blue('Quick Commands (optional):'));
  console.log(chalk.gray('â€¢ status, profile, quests, history, help, clear, exit'));
  console.log(chalk.gray('â€¢ set-name, set-location, set-level'));
  console.log(chalk.gray('â”€'.repeat(50)));
  console.log();
}

async function executeUnifiedChat(message) {
  try {
    const apiClient = createApiClient();
    
    // Send to unified chat endpoint (we'll create this)
    const response = await apiClient.post(`/chat/unified/${config.playerId}`, {
      message: message,
      timestamp: new Date()
    });
    
    const result = response.data.data;
    
    // Display the AI response
    console.log(chalk.cyan(`ðŸ§™â€â™‚ï¸ Guide: ${result.response.message}`));
    
    // Show action confirmations if any actions were executed
    if (result.actionsExecuted && result.actionsExecuted.length > 0) {
      console.log(chalk.green('âœ¨ Actions completed:'));
      result.actionsExecuted.forEach(action => {
        switch (action.type) {
          case 'START_QUEST':
            console.log(chalk.green(`   âš”ï¸  Started quest: ${action.result.quest}`));
            break;
          case 'COMPLETE_QUEST_STEP':
            console.log(chalk.green(`   âœ… Completed step: ${action.result.step}`));
            break;
          case 'COMPLETE_QUEST':
            console.log(chalk.green(`   ðŸ† Quest completed! +${action.result.reward.score} points`));
            break;
        }
      });
    }
    
    // Show metadata
    if (result.response.metadata && result.response.metadata.provider !== 'fallback') {
      console.log(chalk.gray(`   ðŸ’¡ Generated by ${result.response.metadata.provider} (${result.response.metadata.responseTime}ms)`));
    }
    
    // Show helpful suggestions
    if (result.suggestions && result.suggestions.length > 0) {
      console.log(chalk.yellow('ðŸ’­ Suggestions:'));
      result.suggestions.forEach(suggestion => {
        console.log(chalk.gray(`   â€¢ ${suggestion}`));
      });
    }
    
  } catch (error) {
    // Fallback to regular chat if unified endpoint not available
    await fallbackToRegularChat(message);
  }
}

async function fallbackToRegularChat(message) {
  try {
    const apiClient = createApiClient();
    const response = await apiClient.post(`/actions/${config.playerId}`, {
      type: 'CHAT',
      payload: { message },
      playerId: config.playerId,
    });
    
    const result = response.data.data;
    console.log(chalk.cyan(`ðŸ§™â€â™‚ï¸ Guide: ${result.botResponse.message}`));
    
    if (result.llmMetadata && result.llmMetadata.provider !== 'fallback') {
      console.log(chalk.gray(`   ðŸ’¡ Generated by ${result.llmMetadata.provider}`));
    }
  } catch (error) {
    console.log(chalk.red('âŒ Could not reach your guide. Is the realm accessible?'));
  }
}

async function executeQuickCommand(command, args) {
  const apiClient = createApiClient();
  
  try {
    switch (command) {
      case 'status':
        const stateResponse = await apiClient.get(`/state/${config.playerId}`);
        const state = stateResponse.data.data;
        
        console.log(chalk.bold.blue('ðŸ“Š Adventure Status'));
        console.log(chalk.gray('â”€'.repeat(30)));
        console.log(chalk.green(`ðŸ§™â€â™‚ï¸ Adventurer: ${state.player.name}`));
        console.log(chalk.yellow(`â­ Glory: ${state.player.score} points`));
        console.log(chalk.magenta(`ðŸŽ¯ Rank: ${state.player.level}`));
        console.log(chalk.blue(`ðŸŒ Realm: ${state.player.location}`));
        
        if (state.quests.active) {
          const progress = state.quests.active.steps.filter(s => s.completed).length;
          const total = state.quests.active.steps.length;
          console.log(chalk.cyan(`âš”ï¸  Current Quest: ${state.quests.active.title} (${progress}/${total} steps)`));
        } else {
          console.log(chalk.gray('âš”ï¸  Current Quest: Awaiting thy next adventure'));
        }
        break;
        
      case 'profile':
        const profileResponse = await apiClient.get(`/state/${config.playerId}`);
        const profileState = profileResponse.data.data;
        const player = profileState.player;
        
        console.log(chalk.bold.blue('ðŸ‘¤ Player Profile'));
        console.log(chalk.gray('â”€'.repeat(40)));
        console.log(chalk.green(`ðŸ†” ID: ${player.id}`));
        console.log(chalk.green(`ðŸ“› Name: ${player.name}`));
        console.log(chalk.yellow(`â­ Score: ${player.score} points`));
        console.log(chalk.magenta(`ðŸŽ¯ Level: ${player.level}`));
        console.log(chalk.cyan(`ðŸŒ Location: ${player.location}`));
        console.log(chalk.blue(`ðŸŽ­ Status: ${player.status}`));
        
        if (profileState.inventory && profileState.inventory.items.length > 0) {
          console.log(chalk.green(`ðŸŽ’ Inventory: ${profileState.inventory.items.join(', ')}`));
        } else {
          console.log(chalk.gray('ðŸŽ’ Inventory: Empty'));
        }
        
        console.log(chalk.gray('â”€'.repeat(40)));
        console.log(chalk.gray('ðŸ’¡ Tip: Use set-name, set-location, or set-level to edit'));
        break;
        
      case 'set-name':
        const name = args.join(' ');
        if (!name) {
          console.log(chalk.red('âŒ Please provide a name'));
          return;
        }
        
        const nameResponse = await apiClient.put(`/state/${config.playerId}/player`, {
          name: name
        });
        
        if (nameResponse.data.success) {
          console.log(chalk.green(`âœ… Name changed to: ${name}`));
          const player = nameResponse.data.data;
          console.log(chalk.cyan(`ðŸ§™â€â™‚ï¸ Welcome, ${player.name}!`));
        }
        break;
        
      case 'set-location':
        const location = args.join(' ');
        if (!location) {
          console.log(chalk.red('âŒ Please provide a location'));
          return;
        }
        
        const locationResponse = await apiClient.put(`/state/${config.playerId}/player`, {
          location: location
        });
        
        if (locationResponse.data.success) {
          console.log(chalk.green(`âœ… Moved to: ${location}`));
          const player = locationResponse.data.data;
          console.log(chalk.cyan(`ðŸŒ You are now in ${player.location}`));
        }
        break;
        
      case 'set-level':
        const level = args[0];
        const validLevels = ['novice', 'apprentice', 'expert', 'master'];
        
        if (!level || !validLevels.includes(level)) {
          console.log(chalk.red(`âŒ Please provide a valid level: ${validLevels.join(', ')}`));
          return;
        }
        
        const levelResponse = await apiClient.put(`/state/${config.playerId}/player`, {
          level: level
        });
        
        if (levelResponse.data.success) {
          console.log(chalk.green(`âœ… Level changed to: ${level}`));
          const player = levelResponse.data.data;
          console.log(chalk.cyan(`ðŸŽ¯ You are now a ${player.level}!`));
        }
        break;
        
      case 'quests':
        const questsResponse = await apiClient.get(`/quests/${config.playerId}`);
        const quests = questsResponse.data.data;
        
        console.log(chalk.bold.blue('ðŸ—¡ï¸  Available Adventures'));
        console.log(chalk.gray('â”€'.repeat(30)));
        
        if (quests.active) {
          console.log(chalk.green(`âš”ï¸  Active: ${quests.active.title}`));
          console.log(chalk.gray(`   ${quests.active.description}`));
          console.log();
        }
        
        if (quests.available.length > 0) {
          console.log(chalk.blue('ðŸ“‹ Available Quests:'));
          quests.available.forEach((quest, index) => {
            console.log(chalk.yellow(`   ${index + 1}. ${quest.title}`));
            console.log(chalk.gray(`      ${quest.description}`));
            console.log(chalk.cyan(`      Skill: ${quest.realWorldSkill}`));
          });
        }
        break;
        
      case 'history':
        const count = args[0] ? parseInt(args[0], 10) : 5;
        const historyResponse = await apiClient.get(`/state/${config.playerId}`);
        const historyState = historyResponse.data.data;
        const recent = historyState.session.conversationHistory.slice(-count * 2); // Get player + bot pairs
        
        if (recent.length === 0) {
          console.log(chalk.gray('ðŸ“œ No conversations yet. Start by asking your guide something!'));
          return;
        }
        
        console.log(chalk.blue(`ðŸ“œ Recent Conversations (last ${count} exchanges):`));
        console.log(chalk.gray('â”€'.repeat(50)));
        
        for (let i = 0; i < recent.length; i += 2) {
          const playerMsg = recent[i];
          const botMsg = recent[i + 1];
          
          if (playerMsg && playerMsg.sender === 'player') {
            console.log(chalk.green(`ðŸ—£ï¸  You: ${playerMsg.message}`));
          }
          if (botMsg && botMsg.sender === 'bot') {
            console.log(chalk.cyan(`ðŸ§™â€â™‚ï¸ Guide: ${botMsg.message.substring(0, 100)}${botMsg.message.length > 100 ? '...' : ''}`));
          }
          console.log();
        }
        break;
        
      case 'help':
        console.log(chalk.blue('ðŸ§™â€â™‚ï¸ Your AI Adventure Guide Help'));
        console.log(chalk.gray('â”€'.repeat(40)));
        console.log();
        console.log(chalk.cyan('ðŸ—£ï¸  Natural Language Interface (Recommended):'));
        console.log(chalk.yellow('   "I want to start a new quest"'));
        console.log(chalk.yellow('   "I completed finding allies in different time zones"'));
        console.log(chalk.yellow('   "What should I do next?"'));
        console.log(chalk.yellow('   "How am I doing with my current quest?"'));
        console.log(chalk.yellow('   "Show me what adventures are available"'));
        console.log(chalk.yellow('   "I need help understanding the game"'));
        console.log();
        console.log(chalk.cyan('âš¡ Quick Commands:'));
        console.log(chalk.gray('   status       - Show adventure status'));
        console.log(chalk.gray('   profile      - Show detailed player profile'));
        console.log(chalk.gray('   set-name     - Change your character name'));
        console.log(chalk.gray('   set-location - Change your location'));  
        console.log(chalk.gray('   set-level    - Change your level'));
        console.log(chalk.gray('   quests       - List available quests'));
        console.log(chalk.gray('   history      - Show recent conversations'));
        console.log(chalk.gray('   clear        - Clear the screen'));
        console.log(chalk.gray('   exit         - Leave the realm'));
        console.log();
        console.log(chalk.green('ðŸ’¡ Pro tip: Your guide understands natural language! Just speak normally.'));
        break;
        
      default:
        console.log(chalk.red(`âŒ Unknown command: ${command}`));
        console.log(chalk.gray('Try "help" for available commands, or just speak naturally to your guide.'));
    }
  } catch (error) {
    console.log(chalk.red(`âŒ Could not execute ${command}. Is the realm accessible?`));
  }
}

async function processInput(input) {
  const trimmed = input.trim();
  
  if (!trimmed) return;
  
  // Handle exit commands
  if (['exit', 'quit', 'bye', 'farewell'].includes(trimmed.toLowerCase())) {
    console.log(chalk.green('ðŸŒŸ Farewell, brave adventurer! May thy journey continue with wisdom and courage!'));
    process.exit(0);
  }
  
  // Handle clear
  if (trimmed.toLowerCase() === 'clear') {
    console.clear();
    showBanner();
    return;
  }
  
  // Check if it's a quick command
  const parts = trimmed.split(' ');
  const command = parts[0].toLowerCase();
  const args = parts.slice(1);
  
  const quickCommands = ['status', 'quests', 'history', 'help', 'profile', 'set-name', 'set-location', 'set-level'];
  
  if (quickCommands.includes(command)) {
    await executeQuickCommand(command, args);
  } else {
    // Everything else goes to unified chat
    console.log(chalk.green(`ðŸ—£ï¸  You: ${trimmed}`));
    console.log(chalk.gray('ðŸ§™â€â™‚ï¸ Your guide ponders thy words...'));
    await executeUnifiedChat(trimmed);
  }
}

async function checkConnection() {
  try {
    const healthClient = axios.create({
      baseURL: config.engineUrl,
      timeout: 5000,
    });
    const response = await healthClient.get('/health');
    
    console.log(chalk.green('âœ“ Connected to the mystical realm!'));
    if (response.data.llm && response.data.llm.enabled) {
      const providers = Object.entries(response.data.llm.providers)
        .filter(([_, working]) => working)
        .map(([provider, _]) => provider);
      console.log(chalk.green(`âœ¨ AI Guide empowered by: ${providers.join(', ')}`));
    }
    return true;
  } catch (error) {
    console.log(chalk.red('âš ï¸  Warning: Cannot reach the mystical realm'));
    console.log(chalk.gray('   Ensure the realm is accessible: cd packages/engine && npm start'));
    return false;
  }
}

async function startUnifiedShell() {
  console.clear();
  showBanner();
  
  // Test connection
  console.log(chalk.blue('ðŸ”® Connecting to the mystical realm...'));
  const connected = await checkConnection();
  
  if (connected) {
    console.log(chalk.green('ðŸ§™â€â™‚ï¸ Your AI guide awaits! Speak naturally or use quick commands.'));
  } else {
    console.log(chalk.yellow('ðŸ”¥ Running in offline mode. Some features may be limited.'));
  }
  
  console.log(chalk.gray('Type "help" for guidance, or simply tell your guide what you want to do.'));
  console.log();
  
  // Main interaction loop
  while (true) {
    try {
      const { input } = await inquirer.prompt([{
        type: 'input',
        name: 'input',
        message: chalk.cyan('Adventure>'),
        validate: () => true
      }]);
      
      await processInput(input);
      console.log(); // Add spacing between interactions
      
    } catch (error) {
      if (error.name === 'ExitPromptError') {
        console.log(chalk.green('\\nðŸŒŸ Farewell, brave adventurer!'));
        process.exit(0);
      } else {
        console.log(chalk.red('An unexpected enchantment occurred:'), error.message);
      }
    }
  }
}

// Handle Ctrl+C gracefully
process.on('SIGINT', () => {
  console.log(chalk.green('\\nðŸŒŸ Farewell, brave adventurer! Until we meet again!'));
  process.exit(0);
});

// Start the unified shell
startUnifiedShell().catch(error => {
  console.error(chalk.red('Failed to enter the realm:'), error.message);
  process.exit(1);
});
